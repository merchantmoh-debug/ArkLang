// --- Ark Parser Runner (Control Flow Verification) ---

// --- LEXER (Inlined from lexer.ark) ---
TOKEN_EOF := 0
TOKEN_IDENTIFIER := 1
TOKEN_NUMBER := 2
TOKEN_STRING := 3
TOKEN_SYMBOL := 4
TOKEN_KEYWORD := 5

// Keywords
TOKEN_KEYWORD_IF := 100
TOKEN_KEYWORD_ELSE := 101
TOKEN_KEYWORD_WHILE := 102
TOKEN_KEYWORD_FUNC := 103
TOKEN_KEYWORD_RETURN := 104
TOKEN_KEYWORD_LET := 105

// Helper functions (Minified/Mocked if needed, but we use manual tokens here)
// func lexer_tokenize(source) { ... } 

// --- MANUAL TOKENS FOR TEST CASE ---
// Code:
// if x {
//    y := 1
// } else {
//    return 2
// }

func get_test_tokens() {
    return [
        // if
        { type: 100, value: "if", line: 1, col: 1 },
        // x
        { type: 1, value: "x", line: 1, col: 4 },
        // {
        { type: 11, value: "{", line: 1, col: 6 },
        
        // y := 1
        { type: 1, value: "y", line: 2, col: 4 },
        { type: 16, value: ":=", line: 2, col: 6 },
        { type: 2, value: "1", line: 2, col: 9 },
        
        // }
        { type: 12, value: "}", line: 3, col: 1 },
        
        // else
        { type: 101, value: "else", line: 3, col: 3 },
        
        // {
        { type: 11, value: "{", line: 3, col: 8 },
        
        // return 2
        { type: 104, value: "return", line: 4, col: 4 },
        { type: 2, value: "2", line: 4, col: 11 },
        
        // }
        { type: 12, value: "}", line: 5, col: 1 },
        
        // EOF
        { type: 0, value: "", line: 6, col: 1 }
    ]
}

// --- PARSER (Inlined from parser.ark - UPDATED CONSTANTS) ---

// AST NODE TYPES
NODE_PROGRAM := 0
NODE_FUNC_DEF := 1
NODE_BLOCK := 2
NODE_IF := 3
NODE_WHILE := 4
NODE_RETURN := 5
NODE_LET := 6
NODE_ASSIGN := 101
NODE_EXPR_BINARY := 8
NODE_EXPR_CALL := 9
NODE_EXPR_LITERAL_INT := 10
NODE_EXPR_LITERAL_STR := 11
NODE_EXPR_VAR := 12
NODE_EXPR_LITERAL_BOOL := 13

// TOKEN CONSTANTS (Repeated for parser usage)
TOKEN_ASSIGN := 16

func parser_new(tokens) {
    return { tokens: tokens, pos: 0 }
}

func parser_peek(parser) {
    let (tokens, parser) := sys.struct.get(parser, "tokens")
    let (pos, parser) := sys.struct.get(parser, "pos")
    let (len, tokens) := sys.len(tokens)
    
    if pos >= len {
        return [{ type: 0, value: "", line: 0, col: 0 }, parser]
    }
    let (tok, _) := sys.list.get(tokens, pos) 
    return [tok, parser]
}

func parser_advance(parser) {
    let (pos, parser) := sys.struct.get(parser, "pos")
    new_pos := pos + 1
    parser := sys.struct.set(parser, "pos", new_pos)
    return parser
}

// --- EXPRESSION PARSER (Needed for cond/val) ---
func parse_primary(parser) {
    let (tok, p_peek) := parser_peek(parser)
    let (ttype, tok) := sys.struct.get(tok, "type")
    
    if ttype == 2 { // Number
        let (val, tok) := sys.struct.get(tok, "value")
        p_adv := parser_advance(p_peek)
        node := { kind: 10, value: val }
        return [node, p_adv]
    }
    if ttype == 1 { // Identifier
        let (val, tok) := sys.struct.get(tok, "value")
        p_adv := parser_advance(p_peek)
        node := { kind: 12, name: val }
        return [node, p_adv]
    }
    p_adv := parser_advance(p_peek)
    return [{kind: 99, value: "unexpected_primary"}, p_adv]
}
func parse_factor(parser) { return parse_primary(parser) } // Simplified for this test (no * /)
func parse_term(parser) { return parse_factor(parser) }   // Simplified for this test (no + -)
func parse_expr(parser) { return parse_term(parser) }

// --- CONTROL FLOW PARSER ---

func parse_stmt(parser) {
    let (tok, p_peek) := parser_peek(parser)
    let (ttype, tok) := sys.struct.get(tok, "type")
    
    // IF
    if ttype == 100 { return parse_if(p_peek) }
    // WHILE
    if ttype == 102 { return parse_while(p_peek) }
    // RETURN
    if ttype == 104 { return parse_return(p_peek) }
    
    // Identifier (Assign)
    if ttype == 1 {
        // Assume Assignment: IDENT := EXPR
        p_after_id := parser_advance(p_peek) // Consume IDENT
        let (tok2, p_peek2) := parser_peek(p_after_id)
        let (ttype2, tok2) := sys.struct.get(tok2, "type")
        
        if ttype2 == 16 { // :=
             p_after_assign := parser_advance(p_peek2) // Consume :=
             let (expr_node, p_after_expr) := parse_expr(p_after_assign)
             let (id_name, tok) := sys.struct.get(tok, "value")
             node := { kind: 101, name: id_name, value: expr_node }
             return [node, p_after_expr]
        }
    }
    
    p_adv := parser_advance(p_peek)
    return [{kind: 99, value: "skipped"}, p_adv]
}

func parse_block(parser) {
    // Consume {
    let (tok, p_brace) := parser_peek(parser)
    p_curr := parser_advance(p_brace)
    
    children := []
    ref_parser := [p_curr]
    
    running := true
    while running {
        let (p, _) := sys.list.get(ref_parser, 0)
        let (tok, p_peek) := parser_peek(p)
        let (ttype, tok) := sys.struct.get(tok, "type")
        
        // } or EOF
        if ttype == 12 {
            running := false
            p_after_block := parser_advance(p_peek)
            ref_parser := [p_after_block]
        } else if ttype == 0 {
            running := false
            ref_parser := [p_peek] 
        } else {
            let (stmt, p_next) := parse_stmt(p_peek)
            children := sys.list.append(children, stmt)
            ref_parser := [p_next]
        }
    }
    
    let (final_parser, _) := sys.list.get(ref_parser, 0)
    return [children, final_parser]
}

func parse_if(parser) {
    let (tok, p_if) := parser_peek(parser)
    p_after_if := parser_advance(p_if) // Consume if
    
    let (cond, p_after_cond) := parse_expr(p_after_if)
    let (then_stmts, p_after_then) := parse_block(p_after_cond) // Consume { ... }
    
    // Check Else
    let (tok2, p_peek2) := parser_peek(p_after_then)
    let (ttype2, tok2) := sys.struct.get(tok2, "type")
    
    else_block := []
    p_final := p_after_then
    has_else := false
    
    if ttype2 == 101 { // ELSE
        p_after_else := parser_advance(p_peek2) // Consume else
        let (stmts, p_after_else_block) := parse_block(p_after_else)
        else_block := stmts
        p_final := p_after_else_block
        has_else := true
    }
    
    node := { kind: 3, condition: cond, then_block: then_stmts } // NODE_IF
    if has_else {
        node := sys.struct.set(node, "else_block", else_block)
    }
    
    return [node, p_final]
}

func parse_while(parser) {
    let (tok, p_while) := parser_peek(parser)
    p_after_while := parser_advance(p_while) // Consume while
    
    let (cond, p_after_cond) := parse_expr(p_after_while)
    let (stmts, p_final) := parse_block(p_after_cond)
    
    node := { kind: 4, condition: cond, body: stmts } // NODE_WHILE
    return [node, p_final]
}

func parse_return(parser) {
    let (tok, p_ret) := parser_peek(parser)
    p_after_ret := parser_advance(p_ret) // Consume return
    
    let (val, p_final) := parse_expr(p_after_ret)
    
    node := { kind: 5, value: val } // NODE_RETURN
    return [node, p_final]
}

func parse_program(tokens) {
    parser := parser_new(tokens)
    ref_parser := [parser]
    children := []
    
    running := true
    while running {
        let (p, _) := sys.list.get(ref_parser, 0)
        let (tok, p_peek) := parser_peek(p)
        let (ttype, tok) := sys.struct.get(tok, "type")
        
        if ttype == 0 {
            running := false
            ref_parser := [p_peek]
        } else {
            let (node, p_next) := parse_stmt(p_peek)
            children := sys.list.append(children, node)
            ref_parser := [p_next]
        }
    }
    
    return { kind: 0, children: children } // NODE_PROGRAM
}

// --- TEST RUN ---

print("STARTING TEST (Control Flow)")
tokens := get_test_tokens()
ast := parse_program(tokens)
print("Parsing Done.")

// Inspect AST
let (kind, ast) := sys.struct.get(ast, "kind")
print("AST Kind:", kind) // 0

let (children, ast) := sys.struct.get(ast, "children")
let (count, children) := sys.len(children)
print("Children Count:", count) // 1 (The IF stmt)

if count > 0 {
    let (child, children) := sys.list.get(children, 0)
    let (ckind, child) := sys.struct.get(child, "kind")
    print("First Child Kind:", ckind) // 3 (NODE_IF)
    
    // Check Condition
    let (cond, child) := sys.struct.get(child, "condition")
    let (cond_kind, cond) := sys.struct.get(cond, "kind")
    let (cond_name, cond) := sys.struct.get(cond, "name")
    print("Cond Kind:", cond_kind) // 12 (Var)
    print("Cond Name:", cond_name) // x
    
    // Check Then Block
    let (then_blk, child) := sys.struct.get(child, "then_block")
    let (then_len, then_blk) := sys.len(then_blk)
    print("Then Len:", then_len) // 1 (Assignment)
    
    // Check Else Block
    let (else_blk, child) := sys.struct.get(child, "else_block")
    // Else block might be list directly
    let (else_len, else_blk) := sys.len(else_blk)
    print("Else Len:", else_len) // 1 (Return)
    
    if else_len > 0 {
        let (else_stmt, else_blk) := sys.list.get(else_blk, 0)
        let (ekind, else_stmt) := sys.struct.get(else_stmt, "kind")
        print("Else Stmt Kind:", ekind) // 5 (NODE_RETURN)
    }
}
