// apps/market_maker.ark
// Heavyweight Demo: High-Frequency Trading Bot (Mock Exchange)
// Demonstrates: Linear Types, Structs, Event Loop, Math, Networking

import lib.std.math
import lib.std.string
import lib.std.time
import lib.std.net

print("Ark Market Maker v1.0 (Liquid Engine)")
print("=====================================")

// --- Configuration ---
config := {
    PAIR: "ARK/USD",
    SPREAD: 10, // 10 cents ($0.10)
    TICK_SPEED: 100, // ms
    MAX_POSITION_SIZE: 1000,
    EXCHANGE_URL: "http://localhost:9000" // Mock Exchange
}

// --- Data Structures ---

// Order Struct
// id: string
// side: "buy" | "sell"
// price: int (cents)
// size: int
// status: "open" | "filled" | "cancelled"

// OrderBook Struct
// bids: List<Order> (Sorted High -> Low)
// asks: List<Order> (Sorted Low -> High)

// --- State ---
state := {
    position: 0,
    cash: 1000000, // $10,000.00
    open_orders: [],
    last_price: 15000 // $150.00
}

// --- Helpers ---

func generate_order_id() {
    // Generate simple ID
    rand := sys.crypto.random_bytes(4)
    return "ord_" + sys.crypto.hash(rand + sys.time.now())
}

func format_price(p) {
    // p is integer cents, e.g. 15000
    // We want "150.00"
    // string conversion?
    // sys.json.stringify(p) gives "15000"
    
    // Manual string/mod logic
    dollars := p / 100
    cents := p % 100
    
    d_str := sys.json.stringify(dollars)
    c_str := sys.json.stringify(cents)
    
    // Pad cents if < 10
    if cents < 10 {
        c_str := "0" + c_str
    }
    
    return d_str + "." + c_str
}

// --- Trading Logic ---

func calculate_fair_value(book) {
    // Simple Mid Price
    // return (best_bid + best_ask) / 2
    // Mock logic for demo if book empty
    return state.last_price
}

func update_quotes(fair_value) {
    // Calculate new bid/ask
    half_spread := config.SPREAD / 2
    bid_price := fair_value - half_spread
    ask_price := fair_value + half_spread
    
    // Log
    // print("Quote: " + bid_price + " @ " + ask_price)
    
    // In real bot: Cancel old orders, place new ones
    // Here: just simulate "placing" logic
    
    bid_order := {
        id: generate_order_id(),
        side: "buy",
        price: bid_price,
        size: 10,
        status: "open"
    }
    
    ask_order := {
        id: generate_order_id(),
        side: "sell",
        price: ask_price,
        size: 10,
        status: "open"
    }
    
    return [bid_order, ask_order]
}

// --- Network / Exchange Interface ---

func fetch_orderbook() {
    // Mock Network Call
    // In real app: res := sys.net.http.get(config.EXCHANGE_URL + "/book")
    // Return mock book for simulation
    
    // Simulate price walk
    // Pseudo-random using time
    // sys.crypto.random_int does not exist
    t := sys.time.now()
    r := t % 10
    change := r - 5 // -5 to +4
    state.last_price := state.last_price + change
    
    // Mock BBO
    return {
        bids: [{price: state.last_price - 5, size: 100}],
        asks: [{price: state.last_price + 5, size: 100}]
    }
}

// --- Main Loop ---

func run_strategy() {
    print("Starting Strategy Loop...")
    
    while 1 {
        // Fetch
        book := fetch_orderbook()
        
        // Calc
        fv := calculate_fair_value(book)
        
        // Update
        state.latest_orders := update_quotes(fv)
        
        // Print
        let (bid, _) := sys.list.get(state.latest_orders, 0)
        let (ask, _) := sys.list.get(state.latest_orders, 1)
        
        p_str := format_price(state.last_price)
        
        print("TICK | Price: " + p_str)
        
        sys.time.sleep(1)
    }
}

// --- Entry Point ---

// To run thread, we need capability
// But single threaded loop is fine for "Heavyweight Logic" demo
run_strategy()
