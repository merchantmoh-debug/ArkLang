// apps/miner.ark
// Industrial-Grade Stratum Miner
// Protocol: Stratum V1 (JSON-RPC over TCP)

// --- Helpers ---

func string_split_lines(buffer) {
    lines := []
    current := ""
    len_res := sys.len(buffer)
    len := len_res[0]
    i := 0

    while i < len {
        char_res := sys.str.get(buffer, i)
        char := char_res[0]

        if char == "\n" {
            lines := sys.list.append(lines, current)
            current := ""
        } else {
            current := current + char
        }
        i := i + 1
    }

    return [lines, current]
}

func parse_json(s) {
    return sys.json.parse(s)
}

// --- Main Miner Logic ---

func run_miner(ip, port) {
    print(">> [Miner] Connecting to Pool at", ip, ":", port)
    socket := sys.net.socket.connect(ip, port)

    if socket == false {
        print(">> [Miner] Connection Failed!")
        return 0
    }
    print(">> [Miner] Connected. Handle:", socket)

    // 1. Subscribe
    print(">> [Miner] Subscribing...")
    msg_sub := "{\"id\": 1, \"method\": \"mining.subscribe\", \"params\": [\"ArkMiner/1.0\"]}\n"
    sys.net.socket.send(socket, msg_sub)

    buffer := ""
    subscribed := false
    authorized := false

    // State
    job_id := ""
    prevhash := ""
    coinb1 := ""
    coinb2 := ""
    // merkle_branch := []
    version := ""
    nbits := ""
    ntime := ""
    clean_jobs := false

    extranonce1 := ""
    extranonce2_size := 4

    // Target (Start with Max Difficulty / Easy)
    target := "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"

    // Nonce
    nonce := 0

    // Set Socket Timeout
    timeout := 10
    if job_id == "" {
        timeout := 1000
    }
    sys.net.socket.set_timeout(socket, timeout)

    print(">> [Miner] Starting Loop...")

    while true {
        // Update timeout based on state
        if job_id == "" {
             sys.net.socket.set_timeout(socket, 1000)
        } else {
             sys.net.socket.set_timeout(socket, 10)
        }

        // --- 1. Network Handling ---
        chunk := sys.net.socket.recv(socket, 4096)

        if chunk != false {
            if chunk == "" {
                print(">> [Miner] Disconnected by Pool.")
                return 0
            }

            buffer := buffer + chunk
            split_res := string_split_lines(buffer)
            lines := split_res[0]
            buffer := split_res[1]

            num_lines_res := sys.len(lines)
            num_lines := num_lines_res[0]
            j := 0

            while j < num_lines {
                line := sys.list.get(lines, j)[0]
                msg := parse_json(line)

                if sys.struct.has(msg, "result") {
                     res := sys.struct.get(msg, "result")[0]
                     id := sys.struct.get(msg, "id")[0]

                     if id == 1 {
                         extranonce1 := sys.list.get(res, 1)[0]
                         subscribed := true
                         print(">> [Miner] Subscribed. Extranonce1:", extranonce1)

                         // Send Authorize
                         print(">> [Miner] Authorizing...")
                         msg_auth := "{\"id\": 2, \"method\": \"mining.authorize\", \"params\": [\"user\", \"pass\"]}\n"
                         sys.net.socket.send(socket, msg_auth)
                     }

                     if id == 2 {
                         authorized := true
                         print(">> [Miner] Authorized.")
                     }

                     if id == 4 {
                         print(">> [Miner] Share Accepted!")
                         return 1
                     }
                }

                if sys.struct.has(msg, "method") {
                    method := sys.struct.get(msg, "method")[0]
                    if method == "mining.notify" {
                        params := sys.struct.get(msg, "params")[0]
                        job_id := sys.list.get(params, 0)[0]
                        prevhash := sys.list.get(params, 1)[0]
                        ntime := sys.list.get(params, 7)[0]
                        clean_jobs := sys.list.get(params, 8)[0]

                        if clean_jobs {
                            nonce := 0
                        }
                        print(">> [Miner] New Job:", job_id)
                    }
                }

                j := j + 1
            }
        }

        // --- 2. Mining ---
        if subscribed {
             if authorized {
                  if job_id != "" {
                       // Proof of Work
                       header := prevhash + job_id + nonce
                       hash := sys.crypto.hash(header)

                       if hash < target {
                           print(">> [Miner] FOUND BLOCK! Hash:", hash)
                           print(">> [Miner] Submitting...")

                           nonce_str := "" + nonce
                           payload := "{\"id\": 4, \"method\": \"mining.submit\", \"params\": [\"user\", \"" + job_id + "\", \"00000000\", \"" + ntime + "\", \"" + nonce_str + "\"]}\n"
                           sys.net.socket.send(socket, payload)
                       }

                       nonce := nonce + 1
                  }
             }
        }
    }
}

// Check execution mode
// Prevent execution if imported without arguments
args_len_info := sys.len(sys_args)
if args_len_info[0] > 0 {
    script_name := sys_args[0]
    // If run directly: "apps/miner.ark"
    if script_name == "apps/miner.ark" {
         run_miner("127.0.0.1", 3333)
    }
}
